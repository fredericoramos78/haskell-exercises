{-# LANGUAGE OverloadedStrings     #-}
{-# LANGUAGE QuasiQuotes           #-}
{-# LANGUAGE TemplateHaskell       #-}
{-# LANGUAGE TypeFamilies          #-}

module MainWeb where
  
import Yesod
import Database.Persist.Postgresql as S
import Control.Monad.Logger (runStderrLoggingT)
import Control.Monad.Trans.Resource (runResourceT)

import InitDB
import WebApp
import Routes
import Handlers

import Models.AppConfig
import Models.WeeklySummary


---- CHALLENGE #1: move handlers into their own module!
-- Context:
--  `mkYesod` is a combination of `mkYesodData` and `mkYesodDispatch`. The former is how our routes & handlers are connected to Yesod machinery. The latter handles the link
--    between URLs and our handler functions.
-- Details: 
-- * https://stackoverflow.com/questions/56722924/split-yesod-app-source-code-into-multiple-source-files
-- * https://stackoverflow.com/questions/65887147/where-does-the-resourcesapp-come-from-in-yesod
-- * https://www.schoolofhaskell.com/school/advanced-haskell/building-a-file-hosting-service-in-yesod/part%202
--
-- btw, this `resourcesWebApp` is code generated by `mkYesodData` function from the `Routes` module.
mkYesodDispatch "WebApp" resourcesWebApp

---- CHALLENGE #2: move routes into a yesod file
-- Not much to say. We replace `[parseRoutes|...]` inline code with a function call which single param is a file. The contents of the file
--   is basically the same as we had before in the enclosing `[...]`. That code change was all in the `Routes` module.

---- CHALLENGE #3: Handlers returning more specific types (not the generic `Value`)  
-- Yesod has this `JSONResponse a` data type that allows for defining the return of a handler function using a more domain-specific `a` type.
-- Behind the scenes it will handle the conversion of that `a` into a JSON value as long as the `a` type has an instance for `ToJSON` type class.
-- Now all handlers can be of type `Handler (JSONResonse MyDomainType)` instead of the generic `Handler Value`

---- CHALLENGE #4: entity types getting auto generated via `.persistentmodel` files instead of what we have at `InitDB` right now
  
main :: IO ()
main = do
  pool <- runStderrLoggingT $ S.createPostgresqlPool "postgresql://lunch:pass123@localhost:5432/lunchdb" 1
  runResourceT $ runSqlPool (runMigration migrateAll) pool
  warp 3000 $ WebApp pool 


