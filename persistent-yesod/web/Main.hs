{-# LANGUAGE OverloadedStrings     #-}
{-# LANGUAGE QuasiQuotes           #-}
{-# LANGUAGE TemplateHaskell       #-}
{-# LANGUAGE TypeFamilies          #-}

module MainWeb where
  
import Yesod
import Database.Persist.Postgresql as S
import Control.Monad.Logger (runStderrLoggingT)
import Control.Monad.Trans.Resource (runResourceT)

import InitDB
import WebApp
import Routes
import Handlers.GetHandlers
import Handlers.UpdateBudget

import Models.AppConfig
import Models.WeeklySummary


---- CHALLENGE #1: move handlers into their own module!
-- Context:
--  `mkYesod` is a combination of `mkYesodData` and `mkYesodDispatch`. The former is how our routes & handlers are connected to Yesod machinery. The latter handles the link
--    between URLs and our handler functions.
-- Details: 
-- * https://stackoverflow.com/questions/56722924/split-yesod-app-source-code-into-multiple-source-files
-- * https://stackoverflow.com/questions/65887147/where-does-the-resourcesapp-come-from-in-yesod
-- * https://www.schoolofhaskell.com/school/advanced-haskell/building-a-file-hosting-service-in-yesod/part%202
--
-- btw, this `resourcesWebApp` is code generated by `mkYesodData` function from the `Routes` module.
mkYesodDispatch "WebApp" resourcesWebApp

---- CHALLENGE #2: move routes into a yesod file
-- Not much to say. We replace `[parseRoutes|...]` inline code with a function call which single param is a file. The contents of the file
--   is basically the same as we had before in the enclosing `[...]`. That code change was all in the `Routes` module.

---- CHALLENGE #3: Handlers returning more specific types (not the generic `Value`)  
-- Yesod has this `JSONResponse a` data type that allows for defining the return of a handler function using a more domain-specific `a` type.
-- Behind the scenes it will handle the conversion of that `a` into a JSON value as long as the `a` type has an instance for `ToJSON` type class.
-- Now all handlers can be of type `Handler (JSONResonse MyDomainType)` instead of the generic `Handler Value`

---- CHALLENGE #4: entity types getting auto generated via `.persistentmodel` files instead of what we have at `InitDB` right now
-- MWB handles this via two combined changes: first it breaks the `share` block in `InitDB` (more precisely the `mkPersist` call) into multiple 
-- calls, each from a different file/module representing a particular entity. Those are named like `PersistentModels.<EntityName>`. That 
-- `mkPersist(With)` expects a couple of arguments, one of which is the model/entity defition. And that's where the second strategy comes in.
--
-- MWB uses the `persistFileWith` to load up the entity defition from a text file. That's an alternative for the TH (Template Haskell) code embedded 
-- in the `share` block in `InitDB`. 
--
-- I'm not going to replicate all that here but for more details on all this check:
-- * `src/PersistentModels/Import.hs` and look at `mkModel`. This function encapsulates the `mkPersistWith` call and the loading of the entity TH code
--   from file.
-- * `src/PersistentModels/Organization.hs` (or any other entity module) to see that function in action. It relies on splices available via TH
--
-- BTW, migration in MWB is handled using `Rails`, thus outside of the scope of `persistent`. Another reason not to try to replicate all that in here.
  
main :: IO ()
main = do
  pool <- runStderrLoggingT $ S.createPostgresqlPool "postgresql://lunch:pass123@localhost:5432/lunchdb" 1
  runResourceT $ runSqlPool (runMigration migrateAll) pool
  warp 3000 $ WebApp pool 


